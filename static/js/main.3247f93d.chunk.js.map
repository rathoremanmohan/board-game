{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","props","state","tiles","lastFlipped","clicks","resetTiles","bind","flipTile","forEach","tile","matched","flipped","number","i","tileOne","tileTwo","length","swapWith","Math","floor","random","this","setState","index","classes","key","className","join","onClick","flipAllBackOver","lastFlippedTile","map","renderTile","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6PA0HeA,G,wDA/GX,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IAKDC,MAAQ,CACTC,MAAO,GACPC,YAAa,KACbC,OAAQ,GAGZ,EAAKC,WAAa,EAAKA,WAAWC,KAAhB,gBAClB,EAAKC,SAAW,EAAKA,SAASD,KAAd,gBAbD,E,4DAiBHJ,GAMZ,OALAA,EAAMM,SAAQ,SAAAC,GACNA,EAAKC,UACND,EAAKE,SAAU,MAGfT,I,mCASP,IAJA,IAAIA,EAAQ,GAERU,EAAS,EAEJC,EAAI,EAAGA,EArCL,GAqCqBA,GAAI,EAAI,CAGpC,IAAIC,EAAU,CAAEH,SAAS,EAAMD,SAAS,EAAOE,SAFlDA,GAGOG,EAAU,CAAEJ,SAAS,EAAMD,SAAS,EAAOE,UAE/CV,EAAK,sBAAOA,GAAP,CAAcY,EAASC,IAIhC,IAAK,IAAIF,EAAI,EAAGA,EAAIX,EAAMc,OAAQH,IAAK,CAEnC,IAAMI,EAAWC,KAAKC,MAAMD,KAAKE,SAAWlB,EAAMc,QAFf,EAIL,CAACd,EAAMe,GAAWf,EAAMW,IAArDX,EAAMW,GAJ4B,KAIxBX,EAAMe,GAJkB,KAOvCI,KAAKC,SAAS,CAAElB,OAAQ,EAAGF,Y,iCAGnBO,EAAMc,GAAQ,IAAD,OACjBC,EAAU,CAAC,QACXf,EAAKE,UACLa,EAAO,sBAAOA,GAAP,CAAgB,aAEvBf,EAAKC,UACLc,EAAO,sBAAOA,GAAP,CAAgB,aAE3B,IAAIC,EAAG,eAAWF,GAClB,OACE,qBAAeG,UAAWF,EAAQG,KAAK,KAAMC,QAAS,kBAAM,EAAKrB,SAASgB,IAA1E,UACMd,EAAKE,SAAWF,EAAKG,QADjBa,K,+BAKPF,GAEL,IAAIrB,EAAQmB,KAAKpB,MAAMC,MAEnBO,EAAOP,EAAMqB,GAEbnB,EAASiB,KAAKpB,MAAMG,OAAS,EAE7BD,EAAckB,KAAKpB,MAAME,YAE7B,GAAoB,OAAhBA,EACAD,EAAQmB,KAAKQ,gBAAgB3B,GAC7BO,EAAKE,SAAWF,EAAKE,QACrBR,EAAcoB,MACX,CACHd,EAAKE,SAAWF,EAAKE,QACrB,IAAImB,EAAkBT,KAAKpB,MAAMC,MAAMC,GACnC2B,EAAgBlB,SAAWH,EAAKG,SACjCkB,EAAgBpB,SAAU,EAC1BD,EAAKC,SAAU,EACfR,EAAMC,GAAe2B,GAExB3B,EAAc,KAElBD,EAAMqB,GAASd,EACfY,KAAKC,SAAS,CAAClB,SAAQF,QAAOC,kB,+BAI1B,IAAD,OACP,OACI,sBAAKuB,UAAU,MAAf,UACE,6CACE,8CAAiBL,KAAKpB,MAAMG,UAC5B,uBACA,wBAAQwB,QAASP,KAAKhB,WAAYqB,UAAU,QAA5C,sBACA,uBACCL,KAAKpB,MAAMC,MAAM6B,KAAI,SAACtB,EAAMc,GAAP,OAAiB,EAAKS,WAAWvB,EAAMc,a,GA3GvDU,cCIHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.3247f93d.chunk.js","sourcesContent":["import React, {Component} from \"react\";\nimport './App.css';\n\n// Set a constant for the number of tiles to generate at the start of your games.\n// we need put this at the top to make it global.\n\nconst TILE_COUNT = 24;\n\nclass App extends Component {\n    //  set up the constructor.\n\n    constructor(props) {\n        super(props);\n\n        // Our initial state should have a blank list of tiles,\n        // previous flipped tile, and number of clicks for the user starting at 0.\n\n        this.state = {\n            tiles: [],\n            lastFlipped: null,\n            clicks: 0\n        };\n        // Bind the resetTiles function.\n        this.resetTiles = this.resetTiles.bind(this);\n        this.flipTile = this.flipTile.bind(this);\n\n    }\n\n    flipAllBackOver(tiles){\n        tiles.forEach(tile => {\n           if (!tile.matched){\n               tile.flipped = true;\n           }\n        });\n        return tiles;\n    }\n\n    resetTiles() {\n        // start off with a blank tile set.\n        let tiles = [];\n        // And start off with our numbering at 0.\n        let number = 0;\n        // We are going to create two of the same tile for each number.\n        for (let i = 0; i < TILE_COUNT; i +=2 ) {\n         number++;\n         // Create two tiles\n            let tileOne = { flipped: true, matched: false, number };\n            let tileTwo = { flipped: true, matched: false, number };\n            // And add those to the list of tiles\n            tiles = [...tiles, tileOne, tileTwo];\n        }\n\n        // Then randomize the tiles!\n        for (let i = 0; i < tiles.length; i++) {\n            // For each tile, pick a random one to switch it with\n            const swapWith = Math.floor(Math.random() * tiles.length);\n            // Swap the two tiles in place.\n            [tiles[i], tiles[swapWith]] = [tiles[swapWith], tiles[i]];\n        }\n        // Then update the state so the game starts over.\n        this.setState({ clicks: 0, tiles });\n    }\n\n    renderTile (tile, index) {\n        let classes = [\"Tile\"];\n        if (tile.flipped) {\n            classes = [...classes, \"flipped\"];\n        }\n        if (tile.matched) {\n            classes = [...classes, \"matched\"];\n        }\n        let key = `tile-${index}`;\n        return (\n          <div key={key} className={classes.join(\" \")} onClick={() => this.flipTile(index)}>\n              {!tile.flipped && tile.number}\n          </div>\n        );\n    }\n    flipTile(index) {\n        // Create a temporary store for the tiles.\n        let tiles = this.state.tiles;\n        // And grab the current tile we are working with\n        let tile = tiles[index];\n        // Increment the number of clicks.\n        let clicks = this.state.clicks + 1;\n        // and set up a temp for the last tile flipped index\n        let lastFlipped = this.state.lastFlipped;\n\n        if (lastFlipped === null) {\n            tiles = this.flipAllBackOver(tiles);\n            tile.flipped = !tile.flipped;\n            lastFlipped = index;\n        } else {\n            tile.flipped = !tile.flipped;\n            let lastFlippedTile = this.state.tiles[lastFlipped];\n            if (lastFlippedTile.number === tile.number) {\n               lastFlippedTile.matched = true;\n               tile.matched = true;\n               tiles[lastFlipped] = lastFlippedTile;\n            }\n            lastFlipped = null;\n        }\n        tiles[index] = tile;\n        this.setState({clicks, tiles, lastFlipped})\n\n    }\n\n  render() {\n    return (\n        <div className=\"App\">\n          <h1>Memory Game</h1>\n            <strong>Clicks: {this.state.clicks}</strong>\n            <br/>\n            <button onClick={this.resetTiles} className=\"reset\">New Game</button>\n            <hr/>\n            {this.state.tiles.map((tile, index) => this.renderTile(tile, index))}\n        </div>\n    )\n  }\n\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}